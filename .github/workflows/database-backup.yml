name: Database Backup

on:
  # –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 03:00 UTC
  schedule:
    - cron: '0 3 * * *'
  
  # –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫
  workflow_dispatch:
    inputs:
      retention_days:
        description: 'Days to keep old backups'
        required: false
        default: '14'

env:
  BACKUP_RETENTION_DAYS: ${{ github.event.inputs.retention_days || '14' }}

jobs:
  backup:
    name: Backup Database
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install PostgreSQL 17 client
        run: |
          # Add PostgreSQL repository
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/postgresql.gpg
          sudo apt-get update
          
          # Install PostgreSQL 17 client (matches Supabase server version)
          sudo apt-get install -y postgresql-client-17
          
          # Verify installation
          echo "Installed pg_dump version:"
          /usr/lib/postgresql/17/bin/pg_dump --version

      - name: Create backup
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          # Generate filename with timestamp
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_FILE="backup_${TIMESTAMP}.sql"
          BACKUP_FILE_GZ="${BACKUP_FILE}.gz"

          echo "üì¶ Creating backup: ${BACKUP_FILE}"
          
          # Use explicit path to PostgreSQL 17 pg_dump
          /usr/lib/postgresql/17/bin/pg_dump "${DATABASE_URL}" \
            --no-owner \
            --no-privileges \
            --clean \
            --if-exists \
            > "${BACKUP_FILE}"

          # Check if backup was created successfully
          if [ ! -s "${BACKUP_FILE}" ]; then
            echo "‚ùå Backup file is empty or was not created"
            exit 1
          fi

          # Get file size before compression
          ORIGINAL_SIZE=$(du -h "${BACKUP_FILE}" | cut -f1)
          echo "üìä Original size: ${ORIGINAL_SIZE}"

          # Compress backup
          gzip -9 "${BACKUP_FILE}"

          # Get compressed size
          COMPRESSED_SIZE=$(du -h "${BACKUP_FILE_GZ}" | cut -f1)
          echo "üìä Compressed size: ${COMPRESSED_SIZE}"

          # Export variables for next steps
          echo "BACKUP_FILE_GZ=${BACKUP_FILE_GZ}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          echo "ORIGINAL_SIZE=${ORIGINAL_SIZE}" >> $GITHUB_ENV
          echo "COMPRESSED_SIZE=${COMPRESSED_SIZE}" >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: backup-${{ env.TIMESTAMP }}
          name: "üóÑÔ∏è Database Backup ${{ env.TIMESTAMP }}"
          body: |
            ## Automatic Database Backup

            **Date:** ${{ env.TIMESTAMP }}
            **Original Size:** ${{ env.ORIGINAL_SIZE }}
            **Compressed Size:** ${{ env.COMPRESSED_SIZE }}

            ### How to restore:
            ```bash
            # Download and extract
            gunzip backup_${{ env.TIMESTAMP }}.sql.gz

            # Restore to database
            psql $DATABASE_URL < backup_${{ env.TIMESTAMP }}.sql
            ```

            ---
            *Automated backup by GitHub Actions*
          files: ${{ env.BACKUP_FILE_GZ }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old backups
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;
            const retentionDays = parseInt(process.env.BACKUP_RETENTION_DAYS) || 14;
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

            console.log(`üßπ Cleaning up backups older than ${retentionDays} days`);
            console.log(`üìÖ Cutoff date: ${cutoffDate.toISOString()}`);

            // Get all releases
            const releases = await github.rest.repos.listReleases({
              owner,
              repo,
              per_page: 100
            });

            // Filter backup releases older than retention period
            const oldBackups = releases.data.filter(release => {
              if (!release.tag_name.startsWith('backup-')) return false;
              const releaseDate = new Date(release.created_at);
              return releaseDate < cutoffDate;
            });

            console.log(`üóëÔ∏è Found ${oldBackups.length} old backups to delete`);

            // Delete old backups
            for (const backup of oldBackups) {
              console.log(`   Deleting: ${backup.tag_name}`);

              // Delete release
              await github.rest.repos.deleteRelease({
                owner,
                repo,
                release_id: backup.id
              });

              // Delete tag
              try {
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `tags/${backup.tag_name}`
                });
              } catch (e) {
                console.log(`   Tag already deleted or not found: ${backup.tag_name}`);
              }
            }

            console.log('‚úÖ Cleanup complete');

      - name: Send notification on failure
        if: failure()
        uses: actions/github-script@v8
        with:
          script: |
            const { owner, repo } = context.repo;

            await github.rest.issues.create({
              owner,
              repo,
              title: 'üö® Database Backup Failed',
              body: `## Backup Failed

            **Workflow Run:** [View Details](${process.env.GITHUB_SERVER_URL}/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID})
            **Date:** ${new Date().toISOString()}

            Please check the workflow logs for more details.

            ---
            *Automated notification*`,
              labels: ['bug', 'automated']
            });
